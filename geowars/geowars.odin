//------------------------------------------------------------------------------
//  geowars/geowars.odin
//------------------------------------------------------------------------------
package main

import "base:runtime"
import slog "../sokol/log"
import sg "../sokol/gfx"
import sapp "../sokol/app"
import sglue "../sokol/glue"
import m "../math" // Assuming this contains mat4, vec3, identity, ortho, scale, mul

state: struct {
    pass_action: sg.Pass_Action,
    bind: sg.Bindings,
    bg_pip: sg.Pipeline,
    player_pip: sg.Pipeline,
    bg_fs_params: Bg_Fs_Params,
    player_vs_params: Player_Vs_Params,
    player_fs_params: Player_Fs_Params,

    // --- Player Movement State ---
    player_pos: m.vec2,       // Current position
    player_vel: m.vec2,       // Current velocity

    // --- Input State ---
    key_w_down: bool,
    key_s_down: bool,
    key_a_down: bool,
    key_d_down: bool,
}

// --- Movement Constants ---
PLAYER_ACCELERATION      :: 15.0  // Units per second per second
PLAYER_REVERSE_FACTOR    :: 0.5   // Reverse is this % of forward acceleration
PLAYER_DAMPING           :: 2.5   // Higher = stops faster (proportional to velocity)
PLAYER_MAX_SPEED         :: 7.0   // Units per second

// Stride for the vertex buffer (pos: 3 floats, color/uv: 4 floats)
// If your vertex layout changes, update this.
vertex_stride :: size_of(f32) * 7

init :: proc "c" () {
    context = runtime.default_context()
    sg.setup({
        pipeline_pool_size = 4, // bg + player + extras
        environment = sglue.environment(),
        logger = { func = slog.func },
    })

    state.pass_action = {
        colors = { 0 = { load_action = .DONTCARE } },
        depth = { load_action = .DONTCARE },
        stencil = { load_action = .DONTCARE },
    }

    // Quad vertex buffer
    vertices := [?]f32 {
        // pos(xyz)       color/uv(rgba) - adjust if shader only needs pos
        -1.0, -1.0, 0.0,   0.0, 0.0, 0.0, 0.0,
        +1.0, -1.0, 0.0,   1.0, 0.0, 0.0, 0.0,
        -1.0, +1.0, 0.0,   0.0, 1.0, 0.0, 0.0,
        +1.0, +1.0, 0.0,   1.0, 1.0, 0.0, 0.0,
    }
    state.bind.vertex_buffers[0] = sg.make_buffer({
        label = "quad-vertices",
        // FIXED: Use explicit Range creation
        data = sg.Range{ ptr = &vertices[0], size = size_of(vertices) },
    })

    // --- Background Pipeline Setup ---
    // Ensure ATTR_bg_position is generated by sokol-shdc
    bg_shd := sg.make_shader(bg_shader_desc(sg.query_backend()))
    state.bg_pip = sg.make_pipeline({
        label = "background-pipeline",
        shader = bg_shd,
        // Use original syntax style:
        layout = {
            buffers = {
                0 = { stride = vertex_stride }, // Use index = { ... }
            },
            attrs = {
                ATTR_bg_position = { format = .FLOAT2 }, // Use ATTR_... = { ... }
            },
        },
        primitive_type = .TRIANGLE_STRIP,
    })

    // --- Player Pipeline Setup ---
    // Ensure ATTR_player_position is generated by sokol-shdc
    player_shd := sg.make_shader(player_shader_desc(sg.query_backend()))
    state.player_pip = sg.make_pipeline({
        label = "player-pipeline",
        shader = player_shd,
         // Use original syntax style:
        layout = {
           buffers = {
                0 = { stride = vertex_stride }, // Use index = { ... }
            },
            attrs = {
                ATTR_player_position = { format = .FLOAT2 }, // Use ATTR_... = { ... }
            },
        },
        primitive_type = .TRIANGLE_STRIP,
        colors = { 0 = { blend = {
            enabled = true,
            src_factor_rgb = .SRC_ALPHA,
            dst_factor_rgb = .ONE_MINUS_SRC_ALPHA,
        }}},
        depth = { write_enabled = false, compare = .ALWAYS },
    })
}

// Add this function somewhere in geowars.odin
event :: proc "c" (event: ^sapp.Event) {
    context = runtime.default_context() // Set context if needed

    #partial switch event.type {
    case .KEY_DOWN:
        #partial switch event.key_code {
        case .W:     state.key_w_down = true
        case .S:     state.key_s_down = true
        case .A:     state.key_a_down = true
        case .D:     state.key_d_down = true
        case .ESCAPE: sapp.request_quit()
        }
    case .KEY_UP:
         #partial switch event.key_code {
        case .W:     state.key_w_down = false
        case .S:     state.key_s_down = false
        case .A:     state.key_a_down = false
        case .D:     state.key_d_down = false
        }
    // Add other event types if needed (e.g., MOUSE_MOVE)
    }
}

frame :: proc "c" () {
    context = runtime.default_context()
    width := sapp.widthf(); height := sapp.heightf(); aspect := width / height
    current_time := f32(sapp.frame_count()) / 60.0 // Use consistent time
    delta_time := f32(sapp.frame_duration())

    // --- Player Physics Update ---

  // 1. Accel Input
  accel_input := m.vec2_zero()
  if state.key_w_down { accel_input.y += 1.0 }
  if state.key_s_down { accel_input.y -= 1.0 }
  if state.key_a_down { accel_input.x -= 1.0 }
  if state.key_d_down { accel_input.x += 1.0 }
  accel_input_len_sq := m.len_sq_vec2(accel_input)
  if accel_input_len_sq > 0.001 { accel_input = m.norm_vec2(accel_input) }
  // 2. Apply Acceleration & Reverse Factor
  final_accel := accel_input * PLAYER_ACCELERATION
  if state.key_s_down && !state.key_w_down && accel_input.y < -0.5 {
      final_accel = final_accel * PLAYER_REVERSE_FACTOR
  }
  // 3. Update Velocity
  state.player_vel += final_accel * delta_time
  // 4. Apply Damping
  damping_factor := max(0.0, 1.0 - PLAYER_DAMPING * delta_time)
  state.player_vel *= damping_factor
  // 5. Clamp to Max Speed
  vel_len_sq := m.len_sq_vec2(state.player_vel)
  max_speed_sq := PLAYER_MAX_SPEED * PLAYER_MAX_SPEED
  if vel_len_sq > f32(max_speed_sq) {
      state.player_vel = m.norm_vec2(state.player_vel) * PLAYER_MAX_SPEED
  }
  // 6. Update Position
  state.player_pos += state.player_vel * delta_time


  // --- Update Uniforms ---
  state.bg_fs_params.tick = current_time
  state.bg_fs_params.resolution = {width, height}
  state.player_fs_params.tick = current_time // Pass time to FS
  state.player_fs_params.resolution = {width, height}

  // --- Player MVP Matrix (No 3D Rotation Here) ---
  ortho_height :: 1.5; ortho_width := ortho_height * aspect
  proj := m.ortho(-ortho_width, ortho_width, -ortho_height, ortho_height, -1.0, 1.0)
  view := m.identity()

  // Transformation components
  player_scale :: 0.25
  scale_mat := m.scale(m.vec3{player_scale, player_scale, 1.0})
  translate_mat := m.translate(m.vec3{state.player_pos.x, state.player_pos.y, 0.0})

  // Combine transformations: Model = Translate * Scale (No rotation matrix)
  model := m.mul(translate_mat, scale_mat) // REVERTED: Removed rotate_mat

  // Final MVP
  state.player_vs_params.mvp = m.mul(proj, m.mul(view, model)) // REVERTED

  // --- Rendering ---
  sg.begin_pass({ action = state.pass_action, swapchain = sglue.swapchain() })

  // 1. Draw Background (Same as before)
  sg.apply_pipeline(state.bg_pip)
  sg.apply_bindings(state.bind)
  sg.apply_uniforms(UB_bg_fs_params, sg.Range{ ptr = &state.bg_fs_params, size = size_of(state.bg_fs_params) })
  sg.draw(0, 4, 1)


  // 2. Draw Player (Using non-rotating MVP)
  sg.apply_pipeline(state.player_pip)
  sg.apply_bindings(state.bind)
  sg.apply_uniforms(UB_Player_Vs_Params, sg.Range{ ptr = &state.player_vs_params, size = size_of(state.player_vs_params) })
  sg.apply_uniforms(UB_Player_Fs_Params, sg.Range{ ptr = &state.player_fs_params, size = size_of(state.player_fs_params) })
  sg.draw(0, 4, 1)

  sg.end_pass()
  sg.commit()
}

cleanup :: proc "c" () {
    context = runtime.default_context()
    sg.shutdown()
}


main :: proc () {
    sapp.run({
        init_cb = init, frame_cb = frame, cleanup_cb = cleanup,
        event_cb = event, // ADDED: Register the event callback
        width = 800, height = 600, sample_count = 4,
        window_title = "GeoWars Odin", icon = { sokol_default = true },
        logger = { func = slog.func },
    })
}