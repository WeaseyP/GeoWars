//------------------------------------------------------------------------------
//  geowars/geowars.odin
//------------------------------------------------------------------------------
package main

import "base:runtime"
import slog "../sokol/log"
import sg "../sokol/gfx"
import sapp "../sokol/app"
import sglue "../sokol/glue"
import m "../math" // Assuming this contains mat4, vec3, identity, ortho, scale, mul

state: struct {
    pass_action: sg.Pass_Action,
    bind: sg.Bindings,
    bg_pip: sg.Pipeline,
    player_pip: sg.Pipeline,
    // Structs below should match names generated in shader.odin by sokol-shdc
    bg_fs_params: Bg_Fs_Params,
    player_vs_params: Player_Vs_Params,
    player_fs_params: Player_Fs_Params,
}

// Stride for the vertex buffer (pos: 3 floats, color/uv: 4 floats)
// If your vertex layout changes, update this.
vertex_stride :: size_of(f32) * 7

init :: proc "c" () {
    context = runtime.default_context()
    sg.setup({
        pipeline_pool_size = 4, // bg + player + extras
        environment = sglue.environment(),
        logger = { func = slog.func },
    })

    state.pass_action = {
        colors = { 0 = { load_action = .DONTCARE } },
        depth = { load_action = .DONTCARE },
        stencil = { load_action = .DONTCARE },
    }

    // Quad vertex buffer
    vertices := [?]f32 {
        // pos(xyz)       color/uv(rgba) - adjust if shader only needs pos
        -1.0, -1.0, 0.0,   0.0, 0.0, 0.0, 0.0,
        +1.0, -1.0, 0.0,   1.0, 0.0, 0.0, 0.0,
        -1.0, +1.0, 0.0,   0.0, 1.0, 0.0, 0.0,
        +1.0, +1.0, 0.0,   1.0, 1.0, 0.0, 0.0,
    }
    state.bind.vertex_buffers[0] = sg.make_buffer({
        label = "quad-vertices",
        // FIXED: Use explicit Range creation
        data = sg.Range{ ptr = &vertices[0], size = size_of(vertices) },
    })

    // --- Background Pipeline Setup ---
    // Ensure ATTR_bg_position is generated by sokol-shdc
    bg_shd := sg.make_shader(bg_shader_desc(sg.query_backend()))
    state.bg_pip = sg.make_pipeline({
        label = "background-pipeline",
        shader = bg_shd,
        // Use original syntax style:
        layout = {
            buffers = {
                0 = { stride = vertex_stride }, // Use index = { ... }
            },
            attrs = {
                ATTR_bg_position = { format = .FLOAT2 }, // Use ATTR_... = { ... }
            },
        },
        primitive_type = .TRIANGLE_STRIP,
    })

    // --- Player Pipeline Setup ---
    // Ensure ATTR_player_position is generated by sokol-shdc
    player_shd := sg.make_shader(player_shader_desc(sg.query_backend()))
    state.player_pip = sg.make_pipeline({
        label = "player-pipeline",
        shader = player_shd,
         // Use original syntax style:
        layout = {
           buffers = {
                0 = { stride = vertex_stride }, // Use index = { ... }
            },
            attrs = {
                ATTR_player_position = { format = .FLOAT2 }, // Use ATTR_... = { ... }
            },
        },
        primitive_type = .TRIANGLE_STRIP,
        colors = { 0 = { blend = {
            enabled = true,
            src_factor_rgb = .SRC_ALPHA,
            dst_factor_rgb = .ONE_MINUS_SRC_ALPHA,
        }}},
        depth = { write_enabled = false, compare = .ALWAYS },
    })
}


frame :: proc "c" () {
    context = runtime.default_context()
    width := sapp.widthf(); height := sapp.heightf(); aspect := width / height
    current_time := f32(sapp.frame_count()) / 60.0

    // --- Update Uniforms ---
    state.bg_fs_params.tick = current_time
    state.bg_fs_params.resolution = {width, height}

    state.player_fs_params.tick = current_time
    state.player_fs_params.resolution = {width, height}

    // Player MVP Matrix
    ortho_height :: 1.5; ortho_width := ortho_height * aspect
    // FIXED: Ensure m.ortho exists in your math library
    proj := m.ortho(-ortho_width, ortho_width, -ortho_height, ortho_height, -1.0, 1.0)
    view := m.identity() // Assuming m.identity() exists
    player_scale :: 0.25
    // FIXED: Ensure m.scale exists and add vec3 type to literal
    // FIXED: Add type m.vec3 to scale vector literal
    scale_vec := m.vec3{player_scale, player_scale, 1.0}
    model := m.scale(scale_vec) // Assuming m.scale exists

    // Combine: MVP = Projection * View * Model (Assuming m.mul exists)
    state.player_vs_params.mvp = m.mul(proj, m.mul(view, model))

    // --- Rendering ---
    sg.begin_pass({ action = state.pass_action, swapchain = sglue.swapchain() })

    // 1. Draw Background
    sg.apply_pipeline(state.bg_pip)
    sg.apply_bindings(state.bind)
    // FIXED: Use explicit Range, ensure UB_bg_fs_params is generated (likely 0)
    sg.apply_uniforms(UB_bg_fs_params, sg.Range{ ptr = &state.bg_fs_params, size = size_of(state.bg_fs_params) })
    sg.draw(0, 4, 1)

    // 2. Draw Player
    sg.apply_pipeline(state.player_pip)
    sg.apply_bindings(state.bind)
    // FIXED: Use explicit Range and correct generated UB names (check shader.odin!)
    // !! Use the EXACT names generated by sokol-shdc !!
    sg.apply_uniforms(UB_Player_Vs_Params, sg.Range{ ptr = &state.player_vs_params, size = size_of(state.player_vs_params) })
    sg.apply_uniforms(UB_Player_Fs_Params, sg.Range{ ptr = &state.player_fs_params, size = size_of(state.player_fs_params) })
    sg.draw(0, 4, 1)

    sg.end_pass()
    sg.commit()
}


cleanup :: proc "c" () {
    context = runtime.default_context()
    sg.shutdown()
}


main :: proc () {
    sapp.run({
        init_cb = init, frame_cb = frame, cleanup_cb = cleanup,
        width = 800, height = 600, sample_count = 4,
        window_title = "GeoWars Odin", icon = { sokol_default = true },
        logger = { func = slog.func },
    })
}